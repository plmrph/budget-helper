#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getModels(self, modelType):
        """
        Parameters:
         - modelType

        """
        pass

    def deleteModels(self, modelCards):
        """
        Parameters:
         - modelCards

        """
        pass

    def prepareDatasets(self, request):
        """
        Parameters:
         - request

        """
        pass

    def trainModels(self, trainingRequests):
        """
        Parameters:
         - trainingRequests

        """
        pass

    def getPredictions(self, predictionRequests):
        """
        Parameters:
         - predictionRequests

        """
        pass

    def getDatasets(self, datasetIds, budgetId):
        """
        Parameters:
         - datasetIds
         - budgetId

        """
        pass

    def deleteDatasets(self, datasetIds):
        """
        Parameters:
         - datasetIds

        """
        pass

    def cancelTraining(self, modelCard):
        """
        Parameters:
         - modelCard

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getModels(self, modelType):
        """
        Parameters:
         - modelType

        """
        self.send_getModels(modelType)
        return self.recv_getModels()

    def send_getModels(self, modelType):
        self._oprot.writeMessageBegin('getModels', TMessageType.CALL, self._seqid)
        args = getModels_args()
        args.modelType = modelType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        if result.notFound is not None:
            raise result.notFound
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModels failed: unknown result")

    def deleteModels(self, modelCards):
        """
        Parameters:
         - modelCards

        """
        self.send_deleteModels(modelCards)
        return self.recv_deleteModels()

    def send_deleteModels(self, modelCards):
        self._oprot.writeMessageBegin('deleteModels', TMessageType.CALL, self._seqid)
        args = deleteModels_args()
        args.modelCards = modelCards
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.notFound is not None:
            raise result.notFound
        if result.conflict is not None:
            raise result.conflict
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteModels failed: unknown result")

    def prepareDatasets(self, request):
        """
        Parameters:
         - request

        """
        self.send_prepareDatasets(request)
        return self.recv_prepareDatasets()

    def send_prepareDatasets(self, request):
        self._oprot.writeMessageBegin('prepareDatasets', TMessageType.CALL, self._seqid)
        args = prepareDatasets_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prepareDatasets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prepareDatasets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.validationError is not None:
            raise result.validationError
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "prepareDatasets failed: unknown result")

    def trainModels(self, trainingRequests):
        """
        Parameters:
         - trainingRequests

        """
        self.send_trainModels(trainingRequests)
        return self.recv_trainModels()

    def send_trainModels(self, trainingRequests):
        self._oprot.writeMessageBegin('trainModels', TMessageType.CALL, self._seqid)
        args = trainModels_args()
        args.trainingRequests = trainingRequests
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trainModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trainModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.validationError is not None:
            raise result.validationError
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trainModels failed: unknown result")

    def getPredictions(self, predictionRequests):
        """
        Parameters:
         - predictionRequests

        """
        self.send_getPredictions(predictionRequests)
        return self.recv_getPredictions()

    def send_getPredictions(self, predictionRequests):
        self._oprot.writeMessageBegin('getPredictions', TMessageType.CALL, self._seqid)
        args = getPredictions_args()
        args.predictionRequests = predictionRequests
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPredictions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPredictions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.validationError is not None:
            raise result.validationError
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        if result.remoteError is not None:
            raise result.remoteError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPredictions failed: unknown result")

    def getDatasets(self, datasetIds, budgetId):
        """
        Parameters:
         - datasetIds
         - budgetId

        """
        self.send_getDatasets(datasetIds, budgetId)
        return self.recv_getDatasets()

    def send_getDatasets(self, datasetIds, budgetId):
        self._oprot.writeMessageBegin('getDatasets', TMessageType.CALL, self._seqid)
        args = getDatasets_args()
        args.datasetIds = datasetIds
        args.budgetId = budgetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDatasets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDatasets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        if result.notFound is not None:
            raise result.notFound
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDatasets failed: unknown result")

    def deleteDatasets(self, datasetIds):
        """
        Parameters:
         - datasetIds

        """
        self.send_deleteDatasets(datasetIds)
        return self.recv_deleteDatasets()

    def send_deleteDatasets(self, datasetIds):
        self._oprot.writeMessageBegin('deleteDatasets', TMessageType.CALL, self._seqid)
        args = deleteDatasets_args()
        args.datasetIds = datasetIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteDatasets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteDatasets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.notFound is not None:
            raise result.notFound
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteDatasets failed: unknown result")

    def cancelTraining(self, modelCard):
        """
        Parameters:
         - modelCard

        """
        self.send_cancelTraining(modelCard)
        return self.recv_cancelTraining()

    def send_cancelTraining(self, modelCard):
        self._oprot.writeMessageBegin('cancelTraining', TMessageType.CALL, self._seqid)
        args = cancelTraining_args()
        args.modelCard = modelCard
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelTraining(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelTraining_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.notFound is not None:
            raise result.notFound
        if result.conflict is not None:
            raise result.conflict
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cancelTraining failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getModels"] = Processor.process_getModels
        self._processMap["deleteModels"] = Processor.process_deleteModels
        self._processMap["prepareDatasets"] = Processor.process_prepareDatasets
        self._processMap["trainModels"] = Processor.process_trainModels
        self._processMap["getPredictions"] = Processor.process_getPredictions
        self._processMap["getDatasets"] = Processor.process_getDatasets
        self._processMap["deleteDatasets"] = Processor.process_deleteDatasets
        self._processMap["cancelTraining"] = Processor.process_cancelTraining
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getModels(self, seqid, iprot, oprot):
        args = getModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModels_result()
        try:
            result.success = self._handler.getModels(args.modelType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteModels(self, seqid, iprot, oprot):
        args = deleteModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteModels_result()
        try:
            result.success = self._handler.deleteModels(args.modelCards)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except thrift_gen.exceptions.ttypes.ConflictException as conflict:
            msg_type = TMessageType.REPLY
            result.conflict = conflict
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prepareDatasets(self, seqid, iprot, oprot):
        args = prepareDatasets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prepareDatasets_result()
        try:
            result.success = self._handler.prepareDatasets(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.ValidationException as validationError:
            msg_type = TMessageType.REPLY
            result.validationError = validationError
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prepareDatasets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trainModels(self, seqid, iprot, oprot):
        args = trainModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trainModels_result()
        try:
            result.success = self._handler.trainModels(args.trainingRequests)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.ValidationException as validationError:
            msg_type = TMessageType.REPLY
            result.validationError = validationError
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trainModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPredictions(self, seqid, iprot, oprot):
        args = getPredictions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPredictions_result()
        try:
            result.success = self._handler.getPredictions(args.predictionRequests)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.ValidationException as validationError:
            msg_type = TMessageType.REPLY
            result.validationError = validationError
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except thrift_gen.exceptions.ttypes.RemoteServiceException as remoteError:
            msg_type = TMessageType.REPLY
            result.remoteError = remoteError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPredictions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDatasets(self, seqid, iprot, oprot):
        args = getDatasets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDatasets_result()
        try:
            result.success = self._handler.getDatasets(args.datasetIds, args.budgetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDatasets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteDatasets(self, seqid, iprot, oprot):
        args = deleteDatasets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteDatasets_result()
        try:
            result.success = self._handler.deleteDatasets(args.datasetIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteDatasets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelTraining(self, seqid, iprot, oprot):
        args = cancelTraining_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelTraining_result()
        try:
            result.success = self._handler.cancelTraining(args.modelCard)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except thrift_gen.exceptions.ttypes.ConflictException as conflict:
            msg_type = TMessageType.REPLY
            result.conflict = conflict
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancelTraining", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getModels_args(object):
    """
    Attributes:
     - modelType

    """
    thrift_spec = None


    def __init__(self, modelType = None,):
        self.modelType = modelType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getModels_args')
        if self.modelType is not None:
            oprot.writeFieldBegin('modelType', TType.I32, 1)
            oprot.writeI32(self.modelType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getModels_args)
getModels_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'modelType', None, None, ),  # 1
)


class getModels_result(object):
    """
    Attributes:
     - success
     - internalError
     - unauthorized
     - notFound

    """
    thrift_spec = None


    def __init__(self, success = None, internalError = None, unauthorized = None, notFound = None,):
        self.success = success
        self.internalError = internalError
        self.unauthorized = unauthorized
        self.notFound = notFound

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype53, _size50) = iprot.readListBegin()
                    for _i54 in range(_size50):
                        _elem55 = thrift_gen.entities.ttypes.ModelCard()
                        _elem55.read(iprot)
                        self.success.append(_elem55)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter56 in self.success:
                iter56.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 1)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 2)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 3)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getModels_result)
getModels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [thrift_gen.entities.ttypes.ModelCard, None], False), None, ),  # 0
    (1, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 1
    (2, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 3
)


class deleteModels_args(object):
    """
    Attributes:
     - modelCards

    """
    thrift_spec = None


    def __init__(self, modelCards = None,):
        self.modelCards = modelCards

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelCards = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = thrift_gen.entities.ttypes.ModelCard()
                        _elem62.read(iprot)
                        self.modelCards.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteModels_args')
        if self.modelCards is not None:
            oprot.writeFieldBegin('modelCards', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.modelCards))
            for iter63 in self.modelCards:
                iter63.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteModels_args)
deleteModels_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'modelCards', (TType.STRUCT, [thrift_gen.entities.ttypes.ModelCard, None], False), None, ),  # 1
)


class deleteModels_result(object):
    """
    Attributes:
     - success
     - notFound
     - conflict
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, notFound = None, conflict = None, internalError = None, unauthorized = None,):
        self.success = success
        self.notFound = notFound
        self.conflict = conflict
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.conflict = thrift_gen.exceptions.ttypes.ConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 1)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        if self.conflict is not None:
            oprot.writeFieldBegin('conflict', TType.STRUCT, 2)
            self.conflict.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 3)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 4)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteModels_result)
deleteModels_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'conflict', [thrift_gen.exceptions.ttypes.ConflictException, None], None, ),  # 2
    (3, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 3
    (4, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 4
)


class prepareDatasets_args(object):
    """
    Attributes:
     - request

    """
    thrift_spec = None


    def __init__(self, request = None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = DatasetPreparationRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareDatasets_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareDatasets_args)
prepareDatasets_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [DatasetPreparationRequest, None], None, ),  # 1
)


class prepareDatasets_result(object):
    """
    Attributes:
     - success
     - validationError
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, validationError = None, internalError = None, unauthorized = None,):
        self.success = success
        self.validationError = validationError
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DatasetPreparationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.validationError = thrift_gen.exceptions.ttypes.ValidationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareDatasets_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.validationError is not None:
            oprot.writeFieldBegin('validationError', TType.STRUCT, 1)
            self.validationError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareDatasets_result)
prepareDatasets_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [DatasetPreparationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'validationError', [thrift_gen.exceptions.ttypes.ValidationException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
)


class trainModels_args(object):
    """
    Attributes:
     - trainingRequests

    """
    thrift_spec = None


    def __init__(self, trainingRequests = None,):
        self.trainingRequests = trainingRequests

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.trainingRequests = []
                    (_etype67, _size64) = iprot.readListBegin()
                    for _i68 in range(_size64):
                        _elem69 = ModelTrainingRequest()
                        _elem69.read(iprot)
                        self.trainingRequests.append(_elem69)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trainModels_args')
        if self.trainingRequests is not None:
            oprot.writeFieldBegin('trainingRequests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.trainingRequests))
            for iter70 in self.trainingRequests:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trainModels_args)
trainModels_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'trainingRequests', (TType.STRUCT, [ModelTrainingRequest, None], False), None, ),  # 1
)


class trainModels_result(object):
    """
    Attributes:
     - success
     - validationError
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, validationError = None, internalError = None, unauthorized = None,):
        self.success = success
        self.validationError = validationError
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype74, _size71) = iprot.readListBegin()
                    for _i75 in range(_size71):
                        _elem76 = ModelTrainingResult()
                        _elem76.read(iprot)
                        self.success.append(_elem76)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.validationError = thrift_gen.exceptions.ttypes.ValidationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trainModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter77 in self.success:
                iter77.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.validationError is not None:
            oprot.writeFieldBegin('validationError', TType.STRUCT, 1)
            self.validationError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trainModels_result)
trainModels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ModelTrainingResult, None], False), None, ),  # 0
    (1, TType.STRUCT, 'validationError', [thrift_gen.exceptions.ttypes.ValidationException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
)


class getPredictions_args(object):
    """
    Attributes:
     - predictionRequests

    """
    thrift_spec = None


    def __init__(self, predictionRequests = None,):
        self.predictionRequests = predictionRequests

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.predictionRequests = []
                    (_etype81, _size78) = iprot.readListBegin()
                    for _i82 in range(_size78):
                        _elem83 = ModelPredictionBatchRequest()
                        _elem83.read(iprot)
                        self.predictionRequests.append(_elem83)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPredictions_args')
        if self.predictionRequests is not None:
            oprot.writeFieldBegin('predictionRequests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.predictionRequests))
            for iter84 in self.predictionRequests:
                iter84.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPredictions_args)
getPredictions_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'predictionRequests', (TType.STRUCT, [ModelPredictionBatchRequest, None], False), None, ),  # 1
)


class getPredictions_result(object):
    """
    Attributes:
     - success
     - validationError
     - internalError
     - unauthorized
     - remoteError

    """
    thrift_spec = None


    def __init__(self, success = None, validationError = None, internalError = None, unauthorized = None, remoteError = None,):
        self.success = success
        self.validationError = validationError
        self.internalError = internalError
        self.unauthorized = unauthorized
        self.remoteError = remoteError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype88, _size85) = iprot.readListBegin()
                    for _i89 in range(_size85):
                        _elem90 = ModelPredictionResult()
                        _elem90.read(iprot)
                        self.success.append(_elem90)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.validationError = thrift_gen.exceptions.ttypes.ValidationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.remoteError = thrift_gen.exceptions.ttypes.RemoteServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPredictions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter91 in self.success:
                iter91.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.validationError is not None:
            oprot.writeFieldBegin('validationError', TType.STRUCT, 1)
            self.validationError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        if self.remoteError is not None:
            oprot.writeFieldBegin('remoteError', TType.STRUCT, 4)
            self.remoteError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPredictions_result)
getPredictions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ModelPredictionResult, None], False), None, ),  # 0
    (1, TType.STRUCT, 'validationError', [thrift_gen.exceptions.ttypes.ValidationException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
    (4, TType.STRUCT, 'remoteError', [thrift_gen.exceptions.ttypes.RemoteServiceException, None], None, ),  # 4
)


class getDatasets_args(object):
    """
    Attributes:
     - datasetIds
     - budgetId

    """
    thrift_spec = None


    def __init__(self, datasetIds = None, budgetId = None,):
        self.datasetIds = datasetIds
        self.budgetId = budgetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.datasetIds = []
                    (_etype95, _size92) = iprot.readListBegin()
                    for _i96 in range(_size92):
                        _elem97 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.datasetIds.append(_elem97)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.budgetId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDatasets_args')
        if self.datasetIds is not None:
            oprot.writeFieldBegin('datasetIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.datasetIds))
            for iter98 in self.datasetIds:
                oprot.writeString(iter98.encode('utf-8') if sys.version_info[0] == 2 else iter98)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.budgetId is not None:
            oprot.writeFieldBegin('budgetId', TType.STRING, 2)
            oprot.writeString(self.budgetId.encode('utf-8') if sys.version_info[0] == 2 else self.budgetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDatasets_args)
getDatasets_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'datasetIds', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'budgetId', 'UTF8', None, ),  # 2
)


class getDatasets_result(object):
    """
    Attributes:
     - success
     - internalError
     - unauthorized
     - notFound

    """
    thrift_spec = None


    def __init__(self, success = None, internalError = None, unauthorized = None, notFound = None,):
        self.success = success
        self.internalError = internalError
        self.unauthorized = unauthorized
        self.notFound = notFound

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = DatasetInfo()
                        _elem104.read(iprot)
                        self.success.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDatasets_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter105 in self.success:
                iter105.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 1)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 2)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 3)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDatasets_result)
getDatasets_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [DatasetInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 1
    (2, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 3
)


class deleteDatasets_args(object):
    """
    Attributes:
     - datasetIds

    """
    thrift_spec = None


    def __init__(self, datasetIds = None,):
        self.datasetIds = datasetIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.datasetIds = []
                    (_etype109, _size106) = iprot.readListBegin()
                    for _i110 in range(_size106):
                        _elem111 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.datasetIds.append(_elem111)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteDatasets_args')
        if self.datasetIds is not None:
            oprot.writeFieldBegin('datasetIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.datasetIds))
            for iter112 in self.datasetIds:
                oprot.writeString(iter112.encode('utf-8') if sys.version_info[0] == 2 else iter112)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteDatasets_args)
deleteDatasets_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'datasetIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class deleteDatasets_result(object):
    """
    Attributes:
     - success
     - notFound
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, notFound = None, internalError = None, unauthorized = None,):
        self.success = success
        self.notFound = notFound
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype116, _size113) = iprot.readListBegin()
                    for _i117 in range(_size113):
                        _elem118 = iprot.readBool()
                        self.success.append(_elem118)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteDatasets_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BOOL, len(self.success))
            for iter119 in self.success:
                oprot.writeBool(iter119)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 1)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteDatasets_result)
deleteDatasets_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BOOL, None, False), None, ),  # 0
    (1, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
)


class cancelTraining_args(object):
    """
    Attributes:
     - modelCard

    """
    thrift_spec = None


    def __init__(self, modelCard = None,):
        self.modelCard = modelCard

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelTraining_args')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelTraining_args)
cancelTraining_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
)


class cancelTraining_result(object):
    """
    Attributes:
     - success
     - notFound
     - conflict
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, notFound = None, conflict = None, internalError = None, unauthorized = None,):
        self.success = success
        self.notFound = notFound
        self.conflict = conflict
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.conflict = thrift_gen.exceptions.ttypes.ConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelTraining_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 1)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        if self.conflict is not None:
            oprot.writeFieldBegin('conflict', TType.STRUCT, 2)
            self.conflict.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 3)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 4)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelTraining_result)
cancelTraining_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'conflict', [thrift_gen.exceptions.ttypes.ConflictException, None], None, ),  # 2
    (3, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 3
    (4, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 4
)
fix_spec(all_structs)
del all_structs
