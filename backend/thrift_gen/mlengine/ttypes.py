#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import thrift_gen.entities.ttypes
import thrift_gen.exceptions.ttypes

from thrift.transport import TTransport
all_structs = []


class ModelTrainingRequest(object):
    """
    Attributes:
     - modelCard
     - trainingDataLocation
     - parameters

    """
    thrift_spec = None


    def __init__(self, modelCard = None, trainingDataLocation = None, parameters = None,):
        self.modelCard = modelCard
        self.trainingDataLocation = trainingDataLocation
        self.parameters = parameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.trainingDataLocation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelTrainingRequest')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        if self.trainingDataLocation is not None:
            oprot.writeFieldBegin('trainingDataLocation', TType.STRING, 2)
            oprot.writeString(self.trainingDataLocation.encode('utf-8') if sys.version_info[0] == 2 else self.trainingDataLocation)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter7, viter8 in self.parameters.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                oprot.writeString(viter8.encode('utf-8') if sys.version_info[0] == 2 else viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelTrainingResult(object):
    """
    Attributes:
     - modelCard
     - status
     - errorMessage

    """
    thrift_spec = None


    def __init__(self, modelCard = None, status = None, errorMessage = None,):
        self.modelCard = modelCard
        self.status = status
        self.errorMessage = errorMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.errorMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelTrainingResult')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 2)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin('errorMessage', TType.STRING, 3)
            oprot.writeString(self.errorMessage.encode('utf-8') if sys.version_info[0] == 2 else self.errorMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PredictionInput(object):
    """
    Attributes:
     - primitiveBatchInput

    """
    thrift_spec = None


    def __init__(self, primitiveBatchInput = None,):
        self.primitiveBatchInput = primitiveBatchInput

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.primitiveBatchInput = {}
                    (_ktype10, _vtype11, _size9) = iprot.readMapBegin()
                    for _i13 in range(_size9):
                        _key14 = iprot.readI32()
                        _val15 = []
                        (_etype19, _size16) = iprot.readListBegin()
                        for _i20 in range(_size16):
                            _elem21 = thrift_gen.entities.ttypes.PrimitiveValue()
                            _elem21.read(iprot)
                            _val15.append(_elem21)
                        iprot.readListEnd()
                        self.primitiveBatchInput[_key14] = _val15
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PredictionInput')
        if self.primitiveBatchInput is not None:
            oprot.writeFieldBegin('primitiveBatchInput', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.primitiveBatchInput))
            for kiter22, viter23 in self.primitiveBatchInput.items():
                oprot.writeI32(kiter22)
                oprot.writeListBegin(TType.STRUCT, len(viter23))
                for iter24 in viter23:
                    iter24.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CategoricalPredictionResult(object):
    """
    Attributes:
     - predictedCategory
     - confidence

    """
    thrift_spec = None


    def __init__(self, predictedCategory = None, confidence = None,):
        self.predictedCategory = predictedCategory
        self.confidence = confidence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.predictedCategory = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CategoricalPredictionResult')
        if self.predictedCategory is not None:
            oprot.writeFieldBegin('predictedCategory', TType.STRING, 1)
            oprot.writeString(self.predictedCategory.encode('utf-8') if sys.version_info[0] == 2 else self.predictedCategory)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 2)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PredictionBatchResult(object):
    """
    Attributes:
     - categoricalPredictionResults

    """
    thrift_spec = None


    def __init__(self, categoricalPredictionResults = None,):
        self.categoricalPredictionResults = categoricalPredictionResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.categoricalPredictionResults = {}
                    (_ktype26, _vtype27, _size25) = iprot.readMapBegin()
                    for _i29 in range(_size25):
                        _key30 = iprot.readI32()
                        _val31 = []
                        (_etype35, _size32) = iprot.readListBegin()
                        for _i36 in range(_size32):
                            _elem37 = CategoricalPredictionResult()
                            _elem37.read(iprot)
                            _val31.append(_elem37)
                        iprot.readListEnd()
                        self.categoricalPredictionResults[_key30] = _val31
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PredictionBatchResult')
        if self.categoricalPredictionResults is not None:
            oprot.writeFieldBegin('categoricalPredictionResults', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.categoricalPredictionResults))
            for kiter38, viter39 in self.categoricalPredictionResults.items():
                oprot.writeI32(kiter38)
                oprot.writeListBegin(TType.STRUCT, len(viter39))
                for iter40 in viter39:
                    iter40.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelPredictionBatchRequest(object):
    """
    Attributes:
     - modelCard
     - input

    """
    thrift_spec = None


    def __init__(self, modelCard = None, input = None,):
        self.modelCard = modelCard
        self.input = input

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.input = PredictionInput()
                    self.input.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelPredictionBatchRequest')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        if self.input is not None:
            oprot.writeFieldBegin('input', TType.STRUCT, 2)
            self.input.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelPredictionResult(object):
    """
    Attributes:
     - modelCard
     - result
     - errorMessage

    """
    thrift_spec = None


    def __init__(self, modelCard = None, result = None, errorMessage = None,):
        self.modelCard = modelCard
        self.result = result
        self.errorMessage = errorMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.result = PredictionBatchResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.errorMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelPredictionResult')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 2)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin('errorMessage', TType.STRING, 3)
            oprot.writeString(self.errorMessage.encode('utf-8') if sys.version_info[0] == 2 else self.errorMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DatasetPreparationRequest(object):
    """
    Attributes:
     - transactions
     - testSplitRatio
     - minSamplesPerCategory
     - datasetName

    """
    thrift_spec = None


    def __init__(self, transactions = None, testSplitRatio = 0.2000000000000000, minSamplesPerCategory = 1, datasetName = None,):
        self.transactions = transactions
        self.testSplitRatio = testSplitRatio
        self.minSamplesPerCategory = minSamplesPerCategory
        self.datasetName = datasetName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.transactions = thrift_gen.entities.ttypes.Transactions()
                    self.transactions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.testSplitRatio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.minSamplesPerCategory = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.datasetName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DatasetPreparationRequest')
        if self.transactions is not None:
            oprot.writeFieldBegin('transactions', TType.STRUCT, 1)
            self.transactions.write(oprot)
            oprot.writeFieldEnd()
        if self.testSplitRatio is not None:
            oprot.writeFieldBegin('testSplitRatio', TType.DOUBLE, 2)
            oprot.writeDouble(self.testSplitRatio)
            oprot.writeFieldEnd()
        if self.minSamplesPerCategory is not None:
            oprot.writeFieldBegin('minSamplesPerCategory', TType.I32, 3)
            oprot.writeI32(self.minSamplesPerCategory)
            oprot.writeFieldEnd()
        if self.datasetName is not None:
            oprot.writeFieldBegin('datasetName', TType.STRING, 4)
            oprot.writeString(self.datasetName.encode('utf-8') if sys.version_info[0] == 2 else self.datasetName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DatasetInfo(object):
    """
    Attributes:
     - datasetId
     - datasetName
     - trainingDataLocation
     - testDataLocation
     - trainingSamples
     - testSamples
     - categories
     - categoryBreakdown
     - dateFrom
     - dateTo

    """
    thrift_spec = None


    def __init__(self, datasetId = None, datasetName = None, trainingDataLocation = None, testDataLocation = None, trainingSamples = None, testSamples = None, categories = None, categoryBreakdown = None, dateFrom = None, dateTo = None,):
        self.datasetId = datasetId
        self.datasetName = datasetName
        self.trainingDataLocation = trainingDataLocation
        self.testDataLocation = testDataLocation
        self.trainingSamples = trainingSamples
        self.testSamples = testSamples
        self.categories = categories
        self.categoryBreakdown = categoryBreakdown
        self.dateFrom = dateFrom
        self.dateTo = dateTo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.datasetId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.datasetName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.trainingDataLocation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.testDataLocation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.trainingSamples = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.testSamples = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.categories = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.categoryBreakdown = {}
                    (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                    for _i45 in range(_size41):
                        _key46 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val47 = iprot.readI32()
                        self.categoryBreakdown[_key46] = _val47
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.dateFrom = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.dateTo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DatasetInfo')
        if self.datasetId is not None:
            oprot.writeFieldBegin('datasetId', TType.STRING, 1)
            oprot.writeString(self.datasetId.encode('utf-8') if sys.version_info[0] == 2 else self.datasetId)
            oprot.writeFieldEnd()
        if self.datasetName is not None:
            oprot.writeFieldBegin('datasetName', TType.STRING, 2)
            oprot.writeString(self.datasetName.encode('utf-8') if sys.version_info[0] == 2 else self.datasetName)
            oprot.writeFieldEnd()
        if self.trainingDataLocation is not None:
            oprot.writeFieldBegin('trainingDataLocation', TType.STRING, 3)
            oprot.writeString(self.trainingDataLocation.encode('utf-8') if sys.version_info[0] == 2 else self.trainingDataLocation)
            oprot.writeFieldEnd()
        if self.testDataLocation is not None:
            oprot.writeFieldBegin('testDataLocation', TType.STRING, 4)
            oprot.writeString(self.testDataLocation.encode('utf-8') if sys.version_info[0] == 2 else self.testDataLocation)
            oprot.writeFieldEnd()
        if self.trainingSamples is not None:
            oprot.writeFieldBegin('trainingSamples', TType.I32, 5)
            oprot.writeI32(self.trainingSamples)
            oprot.writeFieldEnd()
        if self.testSamples is not None:
            oprot.writeFieldBegin('testSamples', TType.I32, 6)
            oprot.writeI32(self.testSamples)
            oprot.writeFieldEnd()
        if self.categories is not None:
            oprot.writeFieldBegin('categories', TType.I32, 7)
            oprot.writeI32(self.categories)
            oprot.writeFieldEnd()
        if self.categoryBreakdown is not None:
            oprot.writeFieldBegin('categoryBreakdown', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.categoryBreakdown))
            for kiter48, viter49 in self.categoryBreakdown.items():
                oprot.writeString(kiter48.encode('utf-8') if sys.version_info[0] == 2 else kiter48)
                oprot.writeI32(viter49)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.dateFrom is not None:
            oprot.writeFieldBegin('dateFrom', TType.STRING, 9)
            oprot.writeString(self.dateFrom.encode('utf-8') if sys.version_info[0] == 2 else self.dateFrom)
            oprot.writeFieldEnd()
        if self.dateTo is not None:
            oprot.writeFieldBegin('dateTo', TType.STRING, 10)
            oprot.writeString(self.dateTo.encode('utf-8') if sys.version_info[0] == 2 else self.dateTo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DatasetPreparationResult(object):
    """
    Attributes:
     - datasetInfo
     - errorMessage

    """
    thrift_spec = None


    def __init__(self, datasetInfo = None, errorMessage = None,):
        self.datasetInfo = datasetInfo
        self.errorMessage = errorMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.datasetInfo = DatasetInfo()
                    self.datasetInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errorMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DatasetPreparationResult')
        if self.datasetInfo is not None:
            oprot.writeFieldBegin('datasetInfo', TType.STRUCT, 1)
            self.datasetInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin('errorMessage', TType.STRING, 2)
            oprot.writeString(self.errorMessage.encode('utf-8') if sys.version_info[0] == 2 else self.errorMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ModelTrainingRequest)
ModelTrainingRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
    (2, TType.STRING, 'trainingDataLocation', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(ModelTrainingResult)
ModelTrainingResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
    (2, TType.I32, 'status', None, None, ),  # 2
    (3, TType.STRING, 'errorMessage', 'UTF8', None, ),  # 3
)
all_structs.append(PredictionInput)
PredictionInput.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'primitiveBatchInput', (TType.I32, None, TType.LIST, (TType.STRUCT, [thrift_gen.entities.ttypes.PrimitiveValue, None], False), False), None, ),  # 1
)
all_structs.append(CategoricalPredictionResult)
CategoricalPredictionResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'predictedCategory', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'confidence', None, None, ),  # 2
)
all_structs.append(PredictionBatchResult)
PredictionBatchResult.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'categoricalPredictionResults', (TType.I32, None, TType.LIST, (TType.STRUCT, [CategoricalPredictionResult, None], False), False), None, ),  # 1
)
all_structs.append(ModelPredictionBatchRequest)
ModelPredictionBatchRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
    (2, TType.STRUCT, 'input', [PredictionInput, None], None, ),  # 2
)
all_structs.append(ModelPredictionResult)
ModelPredictionResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
    (2, TType.STRUCT, 'result', [PredictionBatchResult, None], None, ),  # 2
    (3, TType.STRING, 'errorMessage', 'UTF8', None, ),  # 3
)
all_structs.append(DatasetPreparationRequest)
DatasetPreparationRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'transactions', [thrift_gen.entities.ttypes.Transactions, None], None, ),  # 1
    (2, TType.DOUBLE, 'testSplitRatio', None, 0.2000000000000000, ),  # 2
    (3, TType.I32, 'minSamplesPerCategory', None, 1, ),  # 3
    (4, TType.STRING, 'datasetName', 'UTF8', None, ),  # 4
)
all_structs.append(DatasetInfo)
DatasetInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'datasetId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'datasetName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'trainingDataLocation', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'testDataLocation', 'UTF8', None, ),  # 4
    (5, TType.I32, 'trainingSamples', None, None, ),  # 5
    (6, TType.I32, 'testSamples', None, None, ),  # 6
    (7, TType.I32, 'categories', None, None, ),  # 7
    (8, TType.MAP, 'categoryBreakdown', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 8
    (9, TType.STRING, 'dateFrom', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'dateTo', 'UTF8', None, ),  # 10
)
all_structs.append(DatasetPreparationResult)
DatasetPreparationResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'datasetInfo', [DatasetInfo, None], None, ),  # 1
    (2, TType.STRING, 'errorMessage', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
