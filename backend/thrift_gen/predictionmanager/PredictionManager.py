#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getModels(self, modelType):
        """
        Parameters:
         - modelType

        """
        pass

    def prepareTrainingData(self, request):
        """
        Parameters:
         - request

        """
        pass

    def trainModel(self, params):
        """
        Parameters:
         - params

        """
        pass

    def getPredictions(self, request):
        """
        Parameters:
         - request

        """
        pass

    def deleteModel(self, modelCard):
        """
        Parameters:
         - modelCard

        """
        pass

    def cancelTraining(self, modelCard):
        """
        Parameters:
         - modelCard

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getModels(self, modelType):
        """
        Parameters:
         - modelType

        """
        self.send_getModels(modelType)
        return self.recv_getModels()

    def send_getModels(self, modelType):
        self._oprot.writeMessageBegin('getModels', TMessageType.CALL, self._seqid)
        args = getModels_args()
        args.modelType = modelType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        if result.notFound is not None:
            raise result.notFound
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModels failed: unknown result")

    def prepareTrainingData(self, request):
        """
        Parameters:
         - request

        """
        self.send_prepareTrainingData(request)
        return self.recv_prepareTrainingData()

    def send_prepareTrainingData(self, request):
        self._oprot.writeMessageBegin('prepareTrainingData', TMessageType.CALL, self._seqid)
        args = prepareTrainingData_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prepareTrainingData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prepareTrainingData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.validationError is not None:
            raise result.validationError
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        if result.notFound is not None:
            raise result.notFound
        raise TApplicationException(TApplicationException.MISSING_RESULT, "prepareTrainingData failed: unknown result")

    def trainModel(self, params):
        """
        Parameters:
         - params

        """
        self.send_trainModel(params)
        return self.recv_trainModel()

    def send_trainModel(self, params):
        self._oprot.writeMessageBegin('trainModel', TMessageType.CALL, self._seqid)
        args = trainModel_args()
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trainModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trainModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.validationError is not None:
            raise result.validationError
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trainModel failed: unknown result")

    def getPredictions(self, request):
        """
        Parameters:
         - request

        """
        self.send_getPredictions(request)
        return self.recv_getPredictions()

    def send_getPredictions(self, request):
        self._oprot.writeMessageBegin('getPredictions', TMessageType.CALL, self._seqid)
        args = getPredictions_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPredictions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPredictions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.validationError is not None:
            raise result.validationError
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        if result.remoteError is not None:
            raise result.remoteError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPredictions failed: unknown result")

    def deleteModel(self, modelCard):
        """
        Parameters:
         - modelCard

        """
        self.send_deleteModel(modelCard)
        return self.recv_deleteModel()

    def send_deleteModel(self, modelCard):
        self._oprot.writeMessageBegin('deleteModel', TMessageType.CALL, self._seqid)
        args = deleteModel_args()
        args.modelCard = modelCard
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.notFound is not None:
            raise result.notFound
        if result.conflict is not None:
            raise result.conflict
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteModel failed: unknown result")

    def cancelTraining(self, modelCard):
        """
        Parameters:
         - modelCard

        """
        self.send_cancelTraining(modelCard)
        return self.recv_cancelTraining()

    def send_cancelTraining(self, modelCard):
        self._oprot.writeMessageBegin('cancelTraining', TMessageType.CALL, self._seqid)
        args = cancelTraining_args()
        args.modelCard = modelCard
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelTraining(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelTraining_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.notFound is not None:
            raise result.notFound
        if result.conflict is not None:
            raise result.conflict
        if result.internalError is not None:
            raise result.internalError
        if result.unauthorized is not None:
            raise result.unauthorized
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cancelTraining failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getModels"] = Processor.process_getModels
        self._processMap["prepareTrainingData"] = Processor.process_prepareTrainingData
        self._processMap["trainModel"] = Processor.process_trainModel
        self._processMap["getPredictions"] = Processor.process_getPredictions
        self._processMap["deleteModel"] = Processor.process_deleteModel
        self._processMap["cancelTraining"] = Processor.process_cancelTraining
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getModels(self, seqid, iprot, oprot):
        args = getModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModels_result()
        try:
            result.success = self._handler.getModels(args.modelType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prepareTrainingData(self, seqid, iprot, oprot):
        args = prepareTrainingData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prepareTrainingData_result()
        try:
            result.success = self._handler.prepareTrainingData(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.ValidationException as validationError:
            msg_type = TMessageType.REPLY
            result.validationError = validationError
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prepareTrainingData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trainModel(self, seqid, iprot, oprot):
        args = trainModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trainModel_result()
        try:
            result.success = self._handler.trainModel(args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.ValidationException as validationError:
            msg_type = TMessageType.REPLY
            result.validationError = validationError
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trainModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPredictions(self, seqid, iprot, oprot):
        args = getPredictions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPredictions_result()
        try:
            result.success = self._handler.getPredictions(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.ValidationException as validationError:
            msg_type = TMessageType.REPLY
            result.validationError = validationError
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except thrift_gen.exceptions.ttypes.RemoteServiceException as remoteError:
            msg_type = TMessageType.REPLY
            result.remoteError = remoteError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPredictions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteModel(self, seqid, iprot, oprot):
        args = deleteModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteModel_result()
        try:
            result.success = self._handler.deleteModel(args.modelCard)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except thrift_gen.exceptions.ttypes.ConflictException as conflict:
            msg_type = TMessageType.REPLY
            result.conflict = conflict
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelTraining(self, seqid, iprot, oprot):
        args = cancelTraining_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelTraining_result()
        try:
            result.success = self._handler.cancelTraining(args.modelCard)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except thrift_gen.exceptions.ttypes.NotFoundException as notFound:
            msg_type = TMessageType.REPLY
            result.notFound = notFound
        except thrift_gen.exceptions.ttypes.ConflictException as conflict:
            msg_type = TMessageType.REPLY
            result.conflict = conflict
        except thrift_gen.exceptions.ttypes.InternalException as internalError:
            msg_type = TMessageType.REPLY
            result.internalError = internalError
        except thrift_gen.exceptions.ttypes.UnauthorizedException as unauthorized:
            msg_type = TMessageType.REPLY
            result.unauthorized = unauthorized
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancelTraining", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getModels_args(object):
    """
    Attributes:
     - modelType

    """
    thrift_spec = None


    def __init__(self, modelType = None,):
        self.modelType = modelType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getModels_args')
        if self.modelType is not None:
            oprot.writeFieldBegin('modelType', TType.I32, 1)
            oprot.writeI32(self.modelType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getModels_args)
getModels_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'modelType', None, None, ),  # 1
)


class getModels_result(object):
    """
    Attributes:
     - success
     - internalError
     - unauthorized
     - notFound

    """
    thrift_spec = None


    def __init__(self, success = None, internalError = None, unauthorized = None, notFound = None,):
        self.success = success
        self.internalError = internalError
        self.unauthorized = unauthorized
        self.notFound = notFound

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = thrift_gen.entities.ttypes.ModelCard()
                        _elem21.read(iprot)
                        self.success.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter22 in self.success:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 1)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 2)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 3)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getModels_result)
getModels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [thrift_gen.entities.ttypes.ModelCard, None], False), None, ),  # 0
    (1, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 1
    (2, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 2
    (3, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 3
)


class prepareTrainingData_args(object):
    """
    Attributes:
     - request

    """
    thrift_spec = None


    def __init__(self, request = None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = TrainingDataPreparationRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareTrainingData_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareTrainingData_args)
prepareTrainingData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [TrainingDataPreparationRequest, None], None, ),  # 1
)


class prepareTrainingData_result(object):
    """
    Attributes:
     - success
     - validationError
     - internalError
     - unauthorized
     - notFound

    """
    thrift_spec = None


    def __init__(self, success = None, validationError = None, internalError = None, unauthorized = None, notFound = None,):
        self.success = success
        self.validationError = validationError
        self.internalError = internalError
        self.unauthorized = unauthorized
        self.notFound = notFound

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = thrift_gen.mlengine.ttypes.DatasetPreparationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.validationError = thrift_gen.exceptions.ttypes.ValidationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareTrainingData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.validationError is not None:
            oprot.writeFieldBegin('validationError', TType.STRUCT, 1)
            self.validationError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 4)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareTrainingData_result)
prepareTrainingData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [thrift_gen.mlengine.ttypes.DatasetPreparationResult, None], None, ),  # 0
    (1, TType.STRUCT, 'validationError', [thrift_gen.exceptions.ttypes.ValidationException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
    (4, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 4
)


class trainModel_args(object):
    """
    Attributes:
     - params

    """
    thrift_spec = None


    def __init__(self, params = None,):
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.params = thrift_gen.mlengine.ttypes.ModelTrainingRequest()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trainModel_args')
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 1)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trainModel_args)
trainModel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'params', [thrift_gen.mlengine.ttypes.ModelTrainingRequest, None], None, ),  # 1
)


class trainModel_result(object):
    """
    Attributes:
     - success
     - validationError
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, validationError = None, internalError = None, unauthorized = None,):
        self.success = success
        self.validationError = validationError
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = thrift_gen.mlengine.ttypes.ModelTrainingResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.validationError = thrift_gen.exceptions.ttypes.ValidationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trainModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.validationError is not None:
            oprot.writeFieldBegin('validationError', TType.STRUCT, 1)
            self.validationError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trainModel_result)
trainModel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [thrift_gen.mlengine.ttypes.ModelTrainingResult, None], None, ),  # 0
    (1, TType.STRUCT, 'validationError', [thrift_gen.exceptions.ttypes.ValidationException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
)


class getPredictions_args(object):
    """
    Attributes:
     - request

    """
    thrift_spec = None


    def __init__(self, request = None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PredictionRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPredictions_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPredictions_args)
getPredictions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [PredictionRequest, None], None, ),  # 1
)


class getPredictions_result(object):
    """
    Attributes:
     - success
     - validationError
     - internalError
     - unauthorized
     - remoteError

    """
    thrift_spec = None


    def __init__(self, success = None, validationError = None, internalError = None, unauthorized = None, remoteError = None,):
        self.success = success
        self.validationError = validationError
        self.internalError = internalError
        self.unauthorized = unauthorized
        self.remoteError = remoteError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PredictionResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.validationError = thrift_gen.exceptions.ttypes.ValidationException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.remoteError = thrift_gen.exceptions.ttypes.RemoteServiceException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPredictions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.validationError is not None:
            oprot.writeFieldBegin('validationError', TType.STRUCT, 1)
            self.validationError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 2)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 3)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        if self.remoteError is not None:
            oprot.writeFieldBegin('remoteError', TType.STRUCT, 4)
            self.remoteError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPredictions_result)
getPredictions_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PredictionResult, None], None, ),  # 0
    (1, TType.STRUCT, 'validationError', [thrift_gen.exceptions.ttypes.ValidationException, None], None, ),  # 1
    (2, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 2
    (3, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 3
    (4, TType.STRUCT, 'remoteError', [thrift_gen.exceptions.ttypes.RemoteServiceException, None], None, ),  # 4
)


class deleteModel_args(object):
    """
    Attributes:
     - modelCard

    """
    thrift_spec = None


    def __init__(self, modelCard = None,):
        self.modelCard = modelCard

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteModel_args')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteModel_args)
deleteModel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
)


class deleteModel_result(object):
    """
    Attributes:
     - success
     - notFound
     - conflict
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, notFound = None, conflict = None, internalError = None, unauthorized = None,):
        self.success = success
        self.notFound = notFound
        self.conflict = conflict
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.conflict = thrift_gen.exceptions.ttypes.ConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 1)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        if self.conflict is not None:
            oprot.writeFieldBegin('conflict', TType.STRUCT, 2)
            self.conflict.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 3)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 4)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteModel_result)
deleteModel_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'conflict', [thrift_gen.exceptions.ttypes.ConflictException, None], None, ),  # 2
    (3, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 3
    (4, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 4
)


class cancelTraining_args(object):
    """
    Attributes:
     - modelCard

    """
    thrift_spec = None


    def __init__(self, modelCard = None,):
        self.modelCard = modelCard

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.modelCard = thrift_gen.entities.ttypes.ModelCard()
                    self.modelCard.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelTraining_args')
        if self.modelCard is not None:
            oprot.writeFieldBegin('modelCard', TType.STRUCT, 1)
            self.modelCard.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelTraining_args)
cancelTraining_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'modelCard', [thrift_gen.entities.ttypes.ModelCard, None], None, ),  # 1
)


class cancelTraining_result(object):
    """
    Attributes:
     - success
     - notFound
     - conflict
     - internalError
     - unauthorized

    """
    thrift_spec = None


    def __init__(self, success = None, notFound = None, conflict = None, internalError = None, unauthorized = None,):
        self.success = success
        self.notFound = notFound
        self.conflict = conflict
        self.internalError = internalError
        self.unauthorized = unauthorized

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.notFound = thrift_gen.exceptions.ttypes.NotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.conflict = thrift_gen.exceptions.ttypes.ConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.internalError = thrift_gen.exceptions.ttypes.InternalException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.unauthorized = thrift_gen.exceptions.ttypes.UnauthorizedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelTraining_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.notFound is not None:
            oprot.writeFieldBegin('notFound', TType.STRUCT, 1)
            self.notFound.write(oprot)
            oprot.writeFieldEnd()
        if self.conflict is not None:
            oprot.writeFieldBegin('conflict', TType.STRUCT, 2)
            self.conflict.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 3)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.unauthorized is not None:
            oprot.writeFieldBegin('unauthorized', TType.STRUCT, 4)
            self.unauthorized.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelTraining_result)
cancelTraining_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'notFound', [thrift_gen.exceptions.ttypes.NotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'conflict', [thrift_gen.exceptions.ttypes.ConflictException, None], None, ),  # 2
    (3, TType.STRUCT, 'internalError', [thrift_gen.exceptions.ttypes.InternalException, None], None, ),  # 3
    (4, TType.STRUCT, 'unauthorized', [thrift_gen.exceptions.ttypes.UnauthorizedException, None], None, ),  # 4
)
fix_spec(all_structs)
del all_structs
